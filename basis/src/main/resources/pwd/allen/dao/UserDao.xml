<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="pwd.allen.dao.UserDao">


    <resultMap id="UserMap" type="pwd.allen.entity.User">
        <id column="id" property="id"/>
        <result column="create_at" property="createAt"/>
        <result column="user_name" property="userName"/>
        <result column="age" property="age"/>
        <result column="status" property="status"/>
        <result column="msg" property="msg"/>
    </resultMap>

    <!-- 设置UserDao的二级缓存
    eviction：缓存的回收策略， 默认的是 LRU。
    flushInterval ：刷新间隔，单位毫秒，默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新。
     size ：引用数目，正整数，代表缓存最多可以存储多少个对象，太大容易导致内存溢出，默认1024
     readOnly ：只读，true/false，设为false时会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 false。
     -->
    <cache/>

    <select id="getById" resultType="pwd.allen.entity.User">
      <!-- id=1时，如果没有配置全局的myGlobal，则myGlobal会被替换成动态绑定的值
        猜想：sql初始化解析时，如果全局属性有配置，则${}会直接被文本替换；如果没有则包装成TextSqlNode，并在sql执行时从参数中解析
       -->
      <if test="id==1">
          -- abc
          <bind name="myGlobal" value="'动态绑定'" />
      </if>
      select id, user_name, status, create_at, age, dept_id, msg from db_user where id = #{id}
      -- 打印下全局变量myGlobal:${myGlobal}
    </select>

<!--    这条select注释掉，因为改成了在Dao接口上以注解的方式配置-->
<!--    <select id="getByList" resultType="pwd.allen.entity.User">-->
<!--    select * from db_user where id = #{param[0]} and user_name=#{param1[1]}-->
<!--    </select>-->

    <select id="getByIdReturnMap" resultType="map">
      select * from db_user where id = #{id}
    </select>

    <select id="getsByUserNameLike" resultType="pwd.allen.entity.User">
    select * from db_user where user_name like #{userName}
    </select>

    <select id="getsByAgeLtReturnMap" resultType="pwd.allen.entity.User">
    select * from db_user where age &lt;= #{age}
    </select>

    <update id="update" parameterType="pwd.allen.entity.User" timeout="5">
        update db_user
        <set>
            <if test="userName != null and userName != ''">
                user_name=#{userName},
            </if>
            <if test="createAt != null">
                create_at=#{createAt, jdbcType=TIMESTAMP},
            </if>
            <if test="age != null">
                age=#{age},
            </if>
            <if test="dept != null and dept.id != null">
                dept_id=#{dept.id},
            </if>
<!--            <if test="msg != null">-->
<!--                msg=#{msg,jdbcType=BLOB},-->
<!--            </if>-->
        </set>
        where id=#{id}
    </update>

    <!-- 联合查询
    方式1 property写级联属性如dept.id
    方式2 用<association>
     -->
    <resultMap id="MyMap" type="pwd.allen.entity.User" extends="UserMap">
        <result column="user_name" property="userName" typeHandler="pwd.allen.typeHandler.MyTypeHandler"/>
        <!--<result column="dept_id" property="dept.id"/>-->
        <!--<result column="dept_name" property="dept.deptName"/>-->
        <association property="dept" javaType="pwd.allen.entity.Department">
            <id column="dept_id" property="id"/>
            <result column="dept_name" property="deptName"/>
        </association>
    </resultMap>
    <select id="getUserAndDept" resultMap="MyMap">
    select du.*, dd.dept_name
    from db_user du left join db_dept dd on dd.id=du.dept_id where du.id=#{id}
    </select>

    <!-- association 分布查询 -->
    <resultMap id="MyMapStep" type="pwd.allen.entity.User" extends="UserMap">
        <association property="dept" select="pwd.allen.dao.DepartmentDao.getById" column="dept_id">
        </association>
    </resultMap>
    <select id="getStep" resultMap="MyMapStep">
    select * from db_user where id=#{id}
    </select>

    <select id="getUsersByDeptId" resultType="pwd.allen.entity.User">
        select * from db_user where dept_id=#{deptId}
    </select>

    <select id="getUsers" resultType="pwd.allen.entity.User">
        <bind name="parameters" value="_parameter" />
        select * from db_user where 1=1
        <if test="col != null and col != ''">
            and #{col} = #{col}
        </if>
        <if test="parameters.deptId != null and parameters.deptId!=''">
             and dept_id = #{parameters.deptId}
        </if>
    </select>

    <sql id="mySql">
        and ${key} = ${value}
    </sql>

    <select id="getByIdAndUserName" resultType="pwd.allen.entity.User">
    select * from db_user where id = #{id} and user_name = #{userName}
        <include refid="mySql">
            <property name="key" value="1"/>
            <property name="value" value="1"/>
        </include>
    </select>

    <select id="selectByMap" resultType="pwd.allen.entity.User">
        <if test="map.type == 1">
            <bind name="newName" value="'type=1'"/>
        </if>
        <if test="map.type != 1">
            <bind name="newName" value="'type!=1'"/>
        </if>
    select id,#{newName} user_name, age, status, create_at from db_user where id = #{map.id} and user_name=#{param1.userName}
    </select>

    <!-- useGeneratedKeys="true"用于mysql这种主键自增的情况
        效果：如果id不为null则使用指定的值作为主键；否则数据库自增，并获取这个自增值然后赋给User -->
    <insert id="addUser" useGeneratedKeys="true" keyProperty="id" databaseId="mysql">
        insert into db_user(id, user_name, age, status, dept_id)
        values(#{id}, #{userName}, #{age}, #{status}, #{dept.id})
    </insert>
    <!-- Oracle不支持自增；可以使用序列来模拟自增 -->
    <insert id="addUser" databaseId="oracle">
        <!-- 在插入之前查询主键值并赋给id -->
        <selectKey keyProperty="id" order="BEFORE" resultType="int">
            select USER_SEQ.nextval from dual
        </selectKey>
        insert into pwd_user(id, name, age, status, createdate, did)
        values(#{id}, #{userName,jdbcType=NULL}, #{age}, #{status},#{createAt}, #{dept.id})
    </insert>

    <!-- 插入或者更新 -->
    <insert id="insertOrUpdateUser" databaseId="mysql">
        insert into db_user(id, user_name, age, status, dept_id,create_at)
        values(#{id}, #{userName}, #{age}, #{status}, #{dept.id}, #{createAt})
        on DUPLICATE KEY UPDATE user_name=VALUES(user_name),age=VALUES(age),status=VALUES(status),dept_id=VALUES(dept_id);
    </insert>
    <!-- 插入或者更新 -->
    <insert id="insertOrUpdateUser" databaseId="oracle">
        MERGE INTO db_user T1
            USING (SELECT #{id} id, #{userName} user_name, #{age} age, #{status} status, #{dept.id} dept_id, #{createAt} create_at FROM dual) T2
            ON ( T1.a=T2.a)
        WHEN MATCHED THEN
            UPDATE SET T1.user_name = T2.use_name
                , T1.age = T2.age
                , T1.status = T2.status
                , T1.dept_id = T2.dept_id
        WHEN NOT MATCHED THEN
            INSERT (id, user_name, age, status, dept_id,create_at) values(T1.id, T1.user_uame, T1.age, T1.status, T1.dept_id, T1.create_at)
    </insert>

    <!-- 批量插入或者更新 -->
    <insert id="insertOrUpdateUserBatsh">
        insert into db_user(id, user_name, age, status, dept_id,create_at) values
        <foreach collection="list" item="item" separator=",">
            (#{item.id}, #{item.userName}, #{item.age}, #{item.status}, #{item.dept.id}, #{item.createAt,jdbcType=TIMESTAMP})
        </foreach>
        on DUPLICATE KEY UPDATE user_name=VALUES(user_name),age=VALUES(age),status=VALUES(status),dept_id=VALUES(dept_id);
    </insert>

    <!-- public void getPageByProcedure();
	1、使用select标签定义调用存储过程
	2、statementType="CALLABLE":表示要调用存储过程
	3、{call procedure_name(params)}
	-->
    <select id="getPageByProcedure4Oracle" statementType="CALLABLE" databaseId="oracle" useCache="false">
		{call my_procedure(
			#{pageNum,mode=IN,jdbcType=INTEGER},
			#{pageSize,mode=IN,jdbcType=INTEGER},
			#{total,mode=OUT,jdbcType=INTEGER},
			#{data,mode=OUT,jdbcType=CURSOR,javaType=ResultSet,resultMap=UserMap}
		)}
	</select>
    <select id="getPageByProcedure4Mysql" statementType="CALLABLE" databaseId="mysql" useCache="false" resultMap="UserMap">
        <![CDATA[
		call my_procedure(
			#{pageNum,mode=IN,jdbcType=INTEGER},
			#{pageSize,mode=IN,jdbcType=INTEGER},
			#{total,mode=OUT,jdbcType=INTEGER}
		)
		]]>
	</select>

</mapper>